"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["node_modules_censo-custody_solana-wallet-adapter_lib_esm_index_js"],{

/***/ "./node_modules/@censo-custody/solana-wallet-adapter/node_modules/eventemitter3/index.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@censo-custody/solana-wallet-adapter/node_modules/eventemitter3/index.js ***!
  \***********************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif (true) {\n  module.exports = EventEmitter;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGNlbnNvLWN1c3RvZHkvc29sYW5hLXdhbGxldC1hZGFwdGVyL25vZGVfbW9kdWxlcy9ldmVudGVtaXR0ZXIzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLEdBQUc7QUFDZCxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsR0FBRztBQUNkLFdBQVcsU0FBUztBQUNwQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsaUJBQWlCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwwREFBMEQsT0FBTztBQUNqRTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQ0FBMEMsU0FBUztBQUNuRDtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUEsZ0JBQWdCLFlBQVk7QUFDNUI7O0FBRUE7QUFDQSw0REFBNEQ7QUFDNUQsZ0VBQWdFO0FBQ2hFLG9FQUFvRTtBQUNwRSx3RUFBd0U7QUFDeEU7QUFDQSwyREFBMkQsU0FBUztBQUNwRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsR0FBRztBQUNkLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsVUFBVTtBQUNyQixXQUFXLEdBQUc7QUFDZCxhQUFhLGNBQWM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFVBQVU7QUFDckIsV0FBVyxHQUFHO0FBQ2QsV0FBVyxTQUFTO0FBQ3BCLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osNERBQTRELFlBQVk7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixhQUFhLGNBQWM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUE2QjtBQUNqQztBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AY2Vuc28tY3VzdG9keS9zb2xhbmEtd2FsbGV0LWFkYXB0ZXIvbm9kZV9tb2R1bGVzL2V2ZW50ZW1pdHRlcjMvaW5kZXguanM/MGQwYSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5XG4gICwgcHJlZml4ID0gJ34nO1xuXG4vKipcbiAqIENvbnN0cnVjdG9yIHRvIGNyZWF0ZSBhIHN0b3JhZ2UgZm9yIG91ciBgRUVgIG9iamVjdHMuXG4gKiBBbiBgRXZlbnRzYCBpbnN0YW5jZSBpcyBhIHBsYWluIG9iamVjdCB3aG9zZSBwcm9wZXJ0aWVzIGFyZSBldmVudCBuYW1lcy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIEV2ZW50cygpIHt9XG5cbi8vXG4vLyBXZSB0cnkgdG8gbm90IGluaGVyaXQgZnJvbSBgT2JqZWN0LnByb3RvdHlwZWAuIEluIHNvbWUgZW5naW5lcyBjcmVhdGluZyBhblxuLy8gaW5zdGFuY2UgaW4gdGhpcyB3YXkgaXMgZmFzdGVyIHRoYW4gY2FsbGluZyBgT2JqZWN0LmNyZWF0ZShudWxsKWAgZGlyZWN0bHkuXG4vLyBJZiBgT2JqZWN0LmNyZWF0ZShudWxsKWAgaXMgbm90IHN1cHBvcnRlZCB3ZSBwcmVmaXggdGhlIGV2ZW50IG5hbWVzIHdpdGggYVxuLy8gY2hhcmFjdGVyIHRvIG1ha2Ugc3VyZSB0aGF0IHRoZSBidWlsdC1pbiBvYmplY3QgcHJvcGVydGllcyBhcmUgbm90XG4vLyBvdmVycmlkZGVuIG9yIHVzZWQgYXMgYW4gYXR0YWNrIHZlY3Rvci5cbi8vXG5pZiAoT2JqZWN0LmNyZWF0ZSkge1xuICBFdmVudHMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAvL1xuICAvLyBUaGlzIGhhY2sgaXMgbmVlZGVkIGJlY2F1c2UgdGhlIGBfX3Byb3RvX19gIHByb3BlcnR5IGlzIHN0aWxsIGluaGVyaXRlZCBpblxuICAvLyBzb21lIG9sZCBicm93c2VycyBsaWtlIEFuZHJvaWQgNCwgaVBob25lIDUuMSwgT3BlcmEgMTEgYW5kIFNhZmFyaSA1LlxuICAvL1xuICBpZiAoIW5ldyBFdmVudHMoKS5fX3Byb3RvX18pIHByZWZpeCA9IGZhbHNlO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudGF0aW9uIG9mIGEgc2luZ2xlIGV2ZW50IGxpc3RlbmVyLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvbmNlPWZhbHNlXSBTcGVjaWZ5IGlmIHRoZSBsaXN0ZW5lciBpcyBhIG9uZS10aW1lIGxpc3RlbmVyLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBFRShmbiwgY29udGV4dCwgb25jZSkge1xuICB0aGlzLmZuID0gZm47XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMub25jZSA9IG9uY2UgfHwgZmFsc2U7XG59XG5cbi8qKlxuICogQWRkIGEgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHtFdmVudEVtaXR0ZXJ9IGVtaXR0ZXIgUmVmZXJlbmNlIHRvIHRoZSBgRXZlbnRFbWl0dGVyYCBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9uY2UgU3BlY2lmeSBpZiB0aGUgbGlzdGVuZXIgaXMgYSBvbmUtdGltZSBsaXN0ZW5lci5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBhZGRMaXN0ZW5lcihlbWl0dGVyLCBldmVudCwgZm4sIGNvbnRleHQsIG9uY2UpIHtcbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgfVxuXG4gIHZhciBsaXN0ZW5lciA9IG5ldyBFRShmbiwgY29udGV4dCB8fCBlbWl0dGVyLCBvbmNlKVxuICAgICwgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBpZiAoIWVtaXR0ZXIuX2V2ZW50c1tldnRdKSBlbWl0dGVyLl9ldmVudHNbZXZ0XSA9IGxpc3RlbmVyLCBlbWl0dGVyLl9ldmVudHNDb3VudCsrO1xuICBlbHNlIGlmICghZW1pdHRlci5fZXZlbnRzW2V2dF0uZm4pIGVtaXR0ZXIuX2V2ZW50c1tldnRdLnB1c2gobGlzdGVuZXIpO1xuICBlbHNlIGVtaXR0ZXIuX2V2ZW50c1tldnRdID0gW2VtaXR0ZXIuX2V2ZW50c1tldnRdLCBsaXN0ZW5lcl07XG5cbiAgcmV0dXJuIGVtaXR0ZXI7XG59XG5cbi8qKlxuICogQ2xlYXIgZXZlbnQgYnkgbmFtZS5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gZW1pdHRlciBSZWZlcmVuY2UgdG8gdGhlIGBFdmVudEVtaXR0ZXJgIGluc3RhbmNlLlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2dCBUaGUgRXZlbnQgbmFtZS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNsZWFyRXZlbnQoZW1pdHRlciwgZXZ0KSB7XG4gIGlmICgtLWVtaXR0ZXIuX2V2ZW50c0NvdW50ID09PSAwKSBlbWl0dGVyLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG4gIGVsc2UgZGVsZXRlIGVtaXR0ZXIuX2V2ZW50c1tldnRdO1xufVxuXG4vKipcbiAqIE1pbmltYWwgYEV2ZW50RW1pdHRlcmAgaW50ZXJmYWNlIHRoYXQgaXMgbW9sZGVkIGFnYWluc3QgdGhlIE5vZGUuanNcbiAqIGBFdmVudEVtaXR0ZXJgIGludGVyZmFjZS5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG4gIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gYW4gYXJyYXkgbGlzdGluZyB0aGUgZXZlbnRzIGZvciB3aGljaCB0aGUgZW1pdHRlciBoYXMgcmVnaXN0ZXJlZFxuICogbGlzdGVuZXJzLlxuICpcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgdmFyIG5hbWVzID0gW11cbiAgICAsIGV2ZW50c1xuICAgICwgbmFtZTtcblxuICBpZiAodGhpcy5fZXZlbnRzQ291bnQgPT09IDApIHJldHVybiBuYW1lcztcblxuICBmb3IgKG5hbWUgaW4gKGV2ZW50cyA9IHRoaXMuX2V2ZW50cykpIHtcbiAgICBpZiAoaGFzLmNhbGwoZXZlbnRzLCBuYW1lKSkgbmFtZXMucHVzaChwcmVmaXggPyBuYW1lLnNsaWNlKDEpIDogbmFtZSk7XG4gIH1cblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHJldHVybiBuYW1lcy5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhldmVudHMpKTtcbiAgfVxuXG4gIHJldHVybiBuYW1lcztcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBsaXN0ZW5lcnMgcmVnaXN0ZXJlZCBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFRoZSByZWdpc3RlcmVkIGxpc3RlbmVycy5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnMoZXZlbnQpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnRcbiAgICAsIGhhbmRsZXJzID0gdGhpcy5fZXZlbnRzW2V2dF07XG5cbiAgaWYgKCFoYW5kbGVycykgcmV0dXJuIFtdO1xuICBpZiAoaGFuZGxlcnMuZm4pIHJldHVybiBbaGFuZGxlcnMuZm5dO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gaGFuZGxlcnMubGVuZ3RoLCBlZSA9IG5ldyBBcnJheShsKTsgaSA8IGw7IGkrKykge1xuICAgIGVlW2ldID0gaGFuZGxlcnNbaV0uZm47XG4gIH1cblxuICByZXR1cm4gZWU7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgbnVtYmVyIG9mIGxpc3RlbmVycyBsaXN0ZW5pbmcgdG8gYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtYmVyIG9mIGxpc3RlbmVycy5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24gbGlzdGVuZXJDb3VudChldmVudCkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudFxuICAgICwgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2dF07XG5cbiAgaWYgKCFsaXN0ZW5lcnMpIHJldHVybiAwO1xuICBpZiAobGlzdGVuZXJzLmZuKSByZXR1cm4gMTtcbiAgcmV0dXJuIGxpc3RlbmVycy5sZW5ndGg7XG59O1xuXG4vKipcbiAqIENhbGxzIGVhY2ggb2YgdGhlIGxpc3RlbmVycyByZWdpc3RlcmVkIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIGV2ZW50IGhhZCBsaXN0ZW5lcnMsIGVsc2UgYGZhbHNlYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdChldmVudCwgYTEsIGEyLCBhMywgYTQsIGE1KSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW2V2dF0pIHJldHVybiBmYWxzZTtcblxuICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2dF1cbiAgICAsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAsIGFyZ3NcbiAgICAsIGk7XG5cbiAgaWYgKGxpc3RlbmVycy5mbikge1xuICAgIGlmIChsaXN0ZW5lcnMub25jZSkgdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXJzLmZuLCB1bmRlZmluZWQsIHRydWUpO1xuXG4gICAgc3dpdGNoIChsZW4pIHtcbiAgICAgIGNhc2UgMTogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0KSwgdHJ1ZTtcbiAgICAgIGNhc2UgMjogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSksIHRydWU7XG4gICAgICBjYXNlIDM6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyKSwgdHJ1ZTtcbiAgICAgIGNhc2UgNDogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzKSwgdHJ1ZTtcbiAgICAgIGNhc2UgNTogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzLCBhNCksIHRydWU7XG4gICAgICBjYXNlIDY6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMywgYTQsIGE1KSwgdHJ1ZTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAxLCBhcmdzID0gbmV3IEFycmF5KGxlbiAtMSk7IGkgPCBsZW47IGkrKykge1xuICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuXG4gICAgbGlzdGVuZXJzLmZuLmFwcGx5KGxpc3RlbmVycy5jb250ZXh0LCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGVuZ3RoID0gbGlzdGVuZXJzLmxlbmd0aFxuICAgICAgLCBqO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAobGlzdGVuZXJzW2ldLm9uY2UpIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyc1tpXS5mbiwgdW5kZWZpbmVkLCB0cnVlKTtcblxuICAgICAgc3dpdGNoIChsZW4pIHtcbiAgICAgICAgY2FzZSAxOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCk7IGJyZWFrO1xuICAgICAgICBjYXNlIDI6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSk7IGJyZWFrO1xuICAgICAgICBjYXNlIDM6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSwgYTIpOyBicmVhaztcbiAgICAgICAgY2FzZSA0OiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEsIGEyLCBhMyk7IGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmICghYXJncykgZm9yIChqID0gMSwgYXJncyA9IG5ldyBBcnJheShsZW4gLTEpOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaiAtIDFdID0gYXJndW1lbnRzW2pdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxpc3RlbmVyc1tpXS5mbi5hcHBseShsaXN0ZW5lcnNbaV0uY29udGV4dCwgYXJncyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIEFkZCBhIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gW2NvbnRleHQ9dGhpc10gVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gb24oZXZlbnQsIGZuLCBjb250ZXh0KSB7XG4gIHJldHVybiBhZGRMaXN0ZW5lcih0aGlzLCBldmVudCwgZm4sIGNvbnRleHQsIGZhbHNlKTtcbn07XG5cbi8qKlxuICogQWRkIGEgb25lLXRpbWUgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBbY29udGV4dD10aGlzXSBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UoZXZlbnQsIGZuLCBjb250ZXh0KSB7XG4gIHJldHVybiBhZGRMaXN0ZW5lcih0aGlzLCBldmVudCwgZm4sIGNvbnRleHQsIHRydWUpO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgdGhlIGxpc3RlbmVycyBvZiBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIE9ubHkgcmVtb3ZlIHRoZSBsaXN0ZW5lcnMgdGhhdCBtYXRjaCB0aGlzIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IE9ubHkgcmVtb3ZlIHRoZSBsaXN0ZW5lcnMgdGhhdCBoYXZlIHRoaXMgY29udGV4dC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb25jZSBPbmx5IHJlbW92ZSBvbmUtdGltZSBsaXN0ZW5lcnMuXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcihldmVudCwgZm4sIGNvbnRleHQsIG9uY2UpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbZXZ0XSkgcmV0dXJuIHRoaXM7XG4gIGlmICghZm4pIHtcbiAgICBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2dF07XG5cbiAgaWYgKGxpc3RlbmVycy5mbikge1xuICAgIGlmIChcbiAgICAgIGxpc3RlbmVycy5mbiA9PT0gZm4gJiZcbiAgICAgICghb25jZSB8fCBsaXN0ZW5lcnMub25jZSkgJiZcbiAgICAgICghY29udGV4dCB8fCBsaXN0ZW5lcnMuY29udGV4dCA9PT0gY29udGV4dClcbiAgICApIHtcbiAgICAgIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGV2ZW50cyA9IFtdLCBsZW5ndGggPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChcbiAgICAgICAgbGlzdGVuZXJzW2ldLmZuICE9PSBmbiB8fFxuICAgICAgICAob25jZSAmJiAhbGlzdGVuZXJzW2ldLm9uY2UpIHx8XG4gICAgICAgIChjb250ZXh0ICYmIGxpc3RlbmVyc1tpXS5jb250ZXh0ICE9PSBjb250ZXh0KVxuICAgICAgKSB7XG4gICAgICAgIGV2ZW50cy5wdXNoKGxpc3RlbmVyc1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBSZXNldCB0aGUgYXJyYXksIG9yIHJlbW92ZSBpdCBjb21wbGV0ZWx5IGlmIHdlIGhhdmUgbm8gbW9yZSBsaXN0ZW5lcnMuXG4gICAgLy9cbiAgICBpZiAoZXZlbnRzLmxlbmd0aCkgdGhpcy5fZXZlbnRzW2V2dF0gPSBldmVudHMubGVuZ3RoID09PSAxID8gZXZlbnRzWzBdIDogZXZlbnRzO1xuICAgIGVsc2UgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbGwgbGlzdGVuZXJzLCBvciB0aG9zZSBvZiB0aGUgc3BlY2lmaWVkIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBbZXZlbnRdIFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyhldmVudCkge1xuICB2YXIgZXZ0O1xuXG4gIGlmIChldmVudCkge1xuICAgIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG4gICAgaWYgKHRoaXMuX2V2ZW50c1tldnRdKSBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy9cbi8vIEFsaWFzIG1ldGhvZHMgbmFtZXMgYmVjYXVzZSBwZW9wbGUgcm9sbCBsaWtlIHRoYXQuXG4vL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUub247XG5cbi8vXG4vLyBFeHBvc2UgdGhlIHByZWZpeC5cbi8vXG5FdmVudEVtaXR0ZXIucHJlZml4ZWQgPSBwcmVmaXg7XG5cbi8vXG4vLyBBbGxvdyBgRXZlbnRFbWl0dGVyYCB0byBiZSBpbXBvcnRlZCBhcyBtb2R1bGUgbmFtZXNwYWNlLlxuLy9cbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbi8vXG4vLyBFeHBvc2UgdGhlIG1vZHVsZS5cbi8vXG5pZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBtb2R1bGUpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@censo-custody/solana-wallet-adapter/node_modules/eventemitter3/index.js\n"));

/***/ }),

/***/ "./node_modules/@censo-custody/solana-wallet-adapter/lib/esm/censocustody.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@censo-custody/solana-wallet-adapter/lib/esm/censocustody.js ***!
  \***********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CensoWallet: function() { return /* binding */ CensoWallet; }\n/* harmony export */ });\n/* harmony import */ var _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/web3.js */ \"./node_modules/@solana/web3.js/lib/index.browser.esm.js\");\n/* harmony import */ var bs58__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! bs58 */ \"./node_modules/bs58/index.js\");\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! uuid */ \"./node_modules/uuid/dist/esm-browser/index.js\");\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! eventemitter3 */ \"./node_modules/@censo-custody/solana-wallet-adapter/node_modules/eventemitter3/index.js\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n\n\n\n\nconst DEFAULT_SIGNATURE_BUFFER = Buffer.alloc(_solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.SIGNATURE_LENGTH_IN_BYTES).fill(0);\nclass CensoWallet extends eventemitter3__WEBPACK_IMPORTED_MODULE_2__.EventEmitter {\n    constructor() {\n        super();\n        this.url = 'https://wallet.censocustody.com';\n        this.cleanUp = () => {\n            [...this._timers].forEach(t => this.clearTimer(t));\n            const wallet = this._wallet;\n            if (wallet) {\n                wallet.close();\n            }\n            this._wallet = null;\n            this.emit('disconnected');\n        };\n        this.clearTimer = (timer) => {\n            this._timers = this._timers.filter(t => t != timer);\n            window.clearInterval(timer);\n        };\n        this.instructionsToSerializableInstructions = (instructions) => instructions.map(i => {\n            return {\n                'programId': i.programId.toBase58(),\n                'accountMetas': i.keys.map(k => {\n                    return {\n                        address: k.pubkey.toBase58(),\n                        signer: k.isSigner,\n                        writable: k.isWritable,\n                    };\n                }),\n                'data': window.btoa(String.fromCharCode(...i.data)),\n            };\n        });\n        this.handleWalletMessage = (data) => {\n            var _a, _b, _c;\n            if (data.type == \"connected\") {\n                this._connecting = false;\n                if (!data.error) {\n                    this.isLoggedIn = true;\n                    if ((_a = data.connected) === null || _a === void 0 ? void 0 : _a.publicKey) {\n                        this._publicKey = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(data.connected.publicKey);\n                    }\n                }\n            }\n            else if ([\"sendTransaction\", \"sendFinalTransaction\"].includes(data.type)) {\n                const transactionIdentifier = (_b = data.sendTransaction) === null || _b === void 0 ? void 0 : _b.identifier;\n                if (transactionIdentifier && transactionIdentifier in this._pendingTransactions) {\n                    if (data.error) {\n                        this._pendingTransactionErrors[transactionIdentifier] = { message: data.error };\n                    }\n                    else {\n                        this._pendingTransactions[transactionIdentifier] = data.sendTransaction || null;\n                    }\n                }\n            }\n            else if (data.type == \"signTransaction\") {\n                const transactionIdentifier = (_c = data.signTransaction) === null || _c === void 0 ? void 0 : _c.identifier;\n                if (transactionIdentifier && transactionIdentifier in this._pendingTransactions) {\n                    if (data.error) {\n                        this._pendingTransactionErrors[transactionIdentifier] = { message: data.error };\n                    }\n                    else {\n                        this._pendingTransactions[transactionIdentifier] = data.signTransaction || null;\n                    }\n                }\n            }\n        };\n        this.isLoggedIn = false;\n        this._pendingTransactions = {};\n        this._pendingTransactionErrors = {};\n        this._timers = [];\n        this._wallet = null;\n        this._connecting = false;\n        this._publicKey = null;\n        window.addEventListener(\"message\", (e) => {\n            this.handleWalletMessage(e.data);\n        });\n    }\n    async connect(url) {\n        try {\n            this.url = url || this.url;\n            const origin = encodeURIComponent(window.location.origin);\n            const connectUrl = `${this.url}/connect?origin=${origin}`;\n            this._connecting = true;\n            this._wallet = window.open(connectUrl, `censo-custody-${origin}`, \"height=900,width=800,menubar=no,status=no,toolbar=no\");\n            if (!this._wallet) {\n                this._connecting = false;\n                throw new Error(\"Unable to connect to wallet\");\n            }\n            this._timers.push(window.setInterval(() => {\n                if (this._wallet.closed) {\n                    this.cleanUp();\n                }\n                else if (this._wallet) {\n                    this._wallet.postMessage({ type: 'heartbeat' }, this.url);\n                }\n            }, 100));\n            return new Promise((resolve, reject) => {\n                const timer = window.setInterval(() => {\n                    if (this.isLoggedIn && this._publicKey) {\n                        this.clearTimer(timer);\n                        resolve(this._publicKey);\n                    }\n                    else if (!this.isLoggedIn && !this._connecting) {\n                        this.clearTimer(timer);\n                        reject(new Error(\"Unable to connect to Censo\"));\n                    }\n                }, 100);\n                this._timers.push(timer);\n            });\n        }\n        catch (error) {\n            throw error;\n        }\n    }\n    async signTransaction(transaction) {\n        this.verifyCanSignRequests([transaction]);\n        try {\n            return this.signOneTransaction(transaction);\n        }\n        catch (error) {\n            throw error;\n        }\n    }\n    async signAllTransactions(transactions) {\n        this.verifyCanSignRequests(transactions);\n        try {\n            return this.signMultipleTransactions(transactions);\n        }\n        catch (error) {\n            throw error;\n        }\n    }\n    async sendTransaction(transaction, connection, options) {\n        try {\n            const wallet = this._wallet;\n            if (!wallet)\n                throw new Error(\"Not Connected\");\n            const transactionIdentifier = (0,uuid__WEBPACK_IMPORTED_MODULE_3__.v4)();\n            this._pendingTransactions[transactionIdentifier] = null;\n            const signers = options ? options.signers : undefined;\n            if (signers && signers.length > 0) {\n                return new Promise((resolve, reject) => {\n                    this.signOneTransaction(transaction, transactionIdentifier).then(walletTransaction => {\n                        this._pendingTransactions[transactionIdentifier] = null;\n                        (signers === null || signers === void 0 ? void 0 : signers.length) && walletTransaction.partialSign(...signers);\n                        wallet.postMessage({\n                            type: \"sendFinalTransaction\", sendFinalTransaction: {\n                                transactionIdentifier,\n                                signaturePubkeyPairs: walletTransaction.signatures.filter(sp => sp.signature != null).map(sp => {\n                                    return {\n                                        'pubkey': sp.publicKey.toBase58(),\n                                        'signature': sp.signature.toString('base64')\n                                    };\n                                })\n                            }\n                        }, this.url);\n                        const timer = window.setInterval(() => {\n                            const pendingTransaction = this._pendingTransactions[transactionIdentifier];\n                            const pendingTransactionError = this._pendingTransactionErrors[transactionIdentifier];\n                            if (pendingTransaction != null || pendingTransactionError != null) {\n                                this.clearTimer(timer);\n                                pendingTransaction && resolve(pendingTransaction.signature);\n                                pendingTransactionError && reject(pendingTransactionError);\n                            }\n                        }, 100);\n                        this._timers.push(timer);\n                    }).catch((error) => {\n                        reject(error);\n                        throw error;\n                    });\n                });\n            }\n            else {\n                const instructions = this.instructionsToSerializableInstructions(transaction.instructions);\n                return new Promise((resolve, reject) => {\n                    wallet.postMessage({\n                        type: \"sendTransaction\",\n                        sendTransaction: { instructions, transactionIdentifier }\n                    }, this.url);\n                    const timer = window.setInterval(() => {\n                        const pendingTransaction = this._pendingTransactions[transactionIdentifier];\n                        const pendingTransactionError = this._pendingTransactionErrors[transactionIdentifier];\n                        if (pendingTransaction != null || pendingTransactionError != null) {\n                            this.clearTimer(timer);\n                            pendingTransaction && resolve(pendingTransaction.signature);\n                            pendingTransactionError && reject(pendingTransactionError);\n                        }\n                    }, 100);\n                    this._timers.push(timer);\n                });\n            }\n        }\n        catch (error) {\n            throw error;\n        }\n    }\n    buildTransaction(pendingTransaction) {\n        let message = _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Message.from(Buffer.from(Uint8Array.from(window.atob(pendingTransaction.message), c => c.charCodeAt(0))));\n        return _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Transaction.populate(message, Array.from({ length: message.header.numRequiredSignatures }, (_v, i) => {\n            let sigPubkeyPair = pendingTransaction.signatures.find(s => s.pubkey == message.accountKeys[i].toBase58());\n            return bs58__WEBPACK_IMPORTED_MODULE_1__.encode(sigPubkeyPair\n                ? Buffer.from(Uint8Array.from(window.atob(sigPubkeyPair.signature), c => c.charCodeAt(0)))\n                : DEFAULT_SIGNATURE_BUFFER);\n        }));\n    }\n    verifyCanSignRequests(transactions) {\n        transactions.forEach(transaction => {\n            if (transaction.signatures.some(s => s.signature != null)) {\n                throw new Error(\"Censo does not support this signing mode\");\n            }\n        });\n    }\n    signOneTransaction(transaction, transactionIdentifier = (0,uuid__WEBPACK_IMPORTED_MODULE_3__.v4)()) {\n        const wallet = this._wallet;\n        if (!wallet)\n            throw new Error(\"Not Connected\");\n        const instructions = this.instructionsToSerializableInstructions(transaction.instructions);\n        this._pendingTransactions[transactionIdentifier] = null;\n        return new Promise((resolve, reject) => {\n            wallet.postMessage({ type: \"signTransaction\", signTransaction: { instructions, transactionIdentifier } }, this.url);\n            const timer = window.setInterval(() => {\n                const pendingTransaction = this._pendingTransactions[transactionIdentifier];\n                const pendingTransactionError = this._pendingTransactionErrors[transactionIdentifier];\n                if (pendingTransaction != null || pendingTransactionError != null) {\n                    this.clearTimer(timer);\n                    pendingTransaction && resolve(this.buildTransaction(pendingTransaction));\n                    pendingTransactionError && reject(pendingTransactionError);\n                }\n            }, 100);\n            this._timers.push(timer);\n        });\n    }\n    signMultipleTransactions(transactions) {\n        const wallet = this._wallet;\n        if (!wallet)\n            throw new Error(\"Not Connected\");\n        const serializedTransactions = transactions.map((t) => {\n            return {\n                instructions: this.instructionsToSerializableInstructions(t.instructions),\n                transactionIdentifier: (0,uuid__WEBPACK_IMPORTED_MODULE_3__.v4)()\n            };\n        });\n        const transactionIdentifiers = serializedTransactions.map((t) => t.transactionIdentifier);\n        transactionIdentifiers.forEach((transactionIdentifier) => this._pendingTransactions[transactionIdentifier] = null);\n        return new Promise((resolve, reject) => {\n            wallet.postMessage({ type: \"signAllTransactions\", signAllTransactions: { transactions: serializedTransactions } }, this.url);\n            const timer = window.setInterval(() => {\n                const pendingTransactions = transactionIdentifiers.map((txId) => this._pendingTransactions[txId]);\n                const pendingTransactionErrors = transactionIdentifiers.map((txId) => this._pendingTransactionErrors[txId]);\n                if (pendingTransactions.every((t) => t != null)) {\n                    this.clearTimer(timer);\n                    resolve(pendingTransactions.map((pt) => this.buildTransaction(pt)));\n                }\n                else if (pendingTransactionErrors.some((e) => e != null)) {\n                    this.clearTimer(timer);\n                    reject(pendingTransactionErrors.find((e) => e != null));\n                }\n            }, 100);\n            this._timers.push(timer);\n        });\n    }\n}\n//# sourceMappingURL=censocustody.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGNlbnNvLWN1c3RvZHkvc29sYW5hLXdhbGxldC1hZGFwdGVyL2xpYi9lc20vY2Vuc29jdXN0b2R5LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUE2RjtBQUNyRTtBQUNZO0FBQ1M7QUFDN0MsaUNBQWlDLE1BQU0sT0FBTyxzRUFBeUI7QUFDaEUsMEJBQTBCLHVEQUFZO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsc0RBQVM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0Y7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0Y7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxTQUFTLGtCQUFrQixPQUFPO0FBQ3BFO0FBQ0Esb0VBQW9FLE9BQU87QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLG1CQUFtQjtBQUNsRTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyx3Q0FBTTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0MscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0RBQU8sTUFBTSxNQUFNO0FBQ3pDLGVBQWUsd0RBQVcsZ0NBQWdDLDhDQUE4QztBQUN4RztBQUNBLG1CQUFtQix3Q0FBVztBQUM5QixrQkFBa0IsTUFBTTtBQUN4QjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSw0REFBNEQsd0NBQU07QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLDRDQUE0Qyx1Q0FBdUM7QUFDcEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHdDQUFNO0FBQzdDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxvREFBb0Qsd0NBQXdDO0FBQzdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AY2Vuc28tY3VzdG9keS9zb2xhbmEtd2FsbGV0LWFkYXB0ZXIvbGliL2VzbS9jZW5zb2N1c3RvZHkuanM/OWE0YyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBNZXNzYWdlLCBQdWJsaWNLZXksIFNJR05BVFVSRV9MRU5HVEhfSU5fQllURVMsIFRyYW5zYWN0aW9uIH0gZnJvbSBcIkBzb2xhbmEvd2ViMy5qc1wiO1xuaW1wb3J0IGJzNTggZnJvbSBcImJzNThcIjtcbmltcG9ydCB7IHY0IGFzIHV1aWR2NCB9IGZyb20gXCJ1dWlkXCI7XG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tIFwiZXZlbnRlbWl0dGVyM1wiO1xuY29uc3QgREVGQVVMVF9TSUdOQVRVUkVfQlVGRkVSID0gQnVmZmVyLmFsbG9jKFNJR05BVFVSRV9MRU5HVEhfSU5fQllURVMpLmZpbGwoMCk7XG5leHBvcnQgY2xhc3MgQ2Vuc29XYWxsZXQgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnVybCA9ICdodHRwczovL3dhbGxldC5jZW5zb2N1c3RvZHkuY29tJztcbiAgICAgICAgdGhpcy5jbGVhblVwID0gKCkgPT4ge1xuICAgICAgICAgICAgWy4uLnRoaXMuX3RpbWVyc10uZm9yRWFjaCh0ID0+IHRoaXMuY2xlYXJUaW1lcih0KSk7XG4gICAgICAgICAgICBjb25zdCB3YWxsZXQgPSB0aGlzLl93YWxsZXQ7XG4gICAgICAgICAgICBpZiAod2FsbGV0KSB7XG4gICAgICAgICAgICAgICAgd2FsbGV0LmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl93YWxsZXQgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdkaXNjb25uZWN0ZWQnKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jbGVhclRpbWVyID0gKHRpbWVyKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl90aW1lcnMgPSB0aGlzLl90aW1lcnMuZmlsdGVyKHQgPT4gdCAhPSB0aW1lcik7XG4gICAgICAgICAgICB3aW5kb3cuY2xlYXJJbnRlcnZhbCh0aW1lcik7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaW5zdHJ1Y3Rpb25zVG9TZXJpYWxpemFibGVJbnN0cnVjdGlvbnMgPSAoaW5zdHJ1Y3Rpb25zKSA9PiBpbnN0cnVjdGlvbnMubWFwKGkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAncHJvZ3JhbUlkJzogaS5wcm9ncmFtSWQudG9CYXNlNTgoKSxcbiAgICAgICAgICAgICAgICAnYWNjb3VudE1ldGFzJzogaS5rZXlzLm1hcChrID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IGsucHVia2V5LnRvQmFzZTU4KCksXG4gICAgICAgICAgICAgICAgICAgICAgICBzaWduZXI6IGsuaXNTaWduZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogay5pc1dyaXRhYmxlLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICdkYXRhJzogd2luZG93LmJ0b2EoU3RyaW5nLmZyb21DaGFyQ29kZSguLi5pLmRhdGEpKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmhhbmRsZVdhbGxldE1lc3NhZ2UgPSAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBpZiAoZGF0YS50eXBlID09IFwiY29ubmVjdGVkXCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKCFkYXRhLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaXNMb2dnZWRJbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoX2EgPSBkYXRhLmNvbm5lY3RlZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnB1YmxpY0tleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHVibGljS2V5ID0gbmV3IFB1YmxpY0tleShkYXRhLmNvbm5lY3RlZC5wdWJsaWNLZXkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoW1wic2VuZFRyYW5zYWN0aW9uXCIsIFwic2VuZEZpbmFsVHJhbnNhY3Rpb25cIl0uaW5jbHVkZXMoZGF0YS50eXBlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uSWRlbnRpZmllciA9IChfYiA9IGRhdGEuc2VuZFRyYW5zYWN0aW9uKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaWRlbnRpZmllcjtcbiAgICAgICAgICAgICAgICBpZiAodHJhbnNhY3Rpb25JZGVudGlmaWVyICYmIHRyYW5zYWN0aW9uSWRlbnRpZmllciBpbiB0aGlzLl9wZW5kaW5nVHJhbnNhY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wZW5kaW5nVHJhbnNhY3Rpb25FcnJvcnNbdHJhbnNhY3Rpb25JZGVudGlmaWVyXSA9IHsgbWVzc2FnZTogZGF0YS5lcnJvciB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGVuZGluZ1RyYW5zYWN0aW9uc1t0cmFuc2FjdGlvbklkZW50aWZpZXJdID0gZGF0YS5zZW5kVHJhbnNhY3Rpb24gfHwgbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRhdGEudHlwZSA9PSBcInNpZ25UcmFuc2FjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb25JZGVudGlmaWVyID0gKF9jID0gZGF0YS5zaWduVHJhbnNhY3Rpb24pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5pZGVudGlmaWVyO1xuICAgICAgICAgICAgICAgIGlmICh0cmFuc2FjdGlvbklkZW50aWZpZXIgJiYgdHJhbnNhY3Rpb25JZGVudGlmaWVyIGluIHRoaXMuX3BlbmRpbmdUcmFuc2FjdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdUcmFuc2FjdGlvbkVycm9yc1t0cmFuc2FjdGlvbklkZW50aWZpZXJdID0geyBtZXNzYWdlOiBkYXRhLmVycm9yIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9wZW5kaW5nVHJhbnNhY3Rpb25zW3RyYW5zYWN0aW9uSWRlbnRpZmllcl0gPSBkYXRhLnNpZ25UcmFuc2FjdGlvbiB8fCBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmlzTG9nZ2VkSW4gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcGVuZGluZ1RyYW5zYWN0aW9ucyA9IHt9O1xuICAgICAgICB0aGlzLl9wZW5kaW5nVHJhbnNhY3Rpb25FcnJvcnMgPSB7fTtcbiAgICAgICAgdGhpcy5fdGltZXJzID0gW107XG4gICAgICAgIHRoaXMuX3dhbGxldCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2Nvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcHVibGljS2V5ID0gbnVsbDtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIChlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZVdhbGxldE1lc3NhZ2UoZS5kYXRhKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGNvbm5lY3QodXJsKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnVybCA9IHVybCB8fCB0aGlzLnVybDtcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbiA9IGVuY29kZVVSSUNvbXBvbmVudCh3aW5kb3cubG9jYXRpb24ub3JpZ2luKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbm5lY3RVcmwgPSBgJHt0aGlzLnVybH0vY29ubmVjdD9vcmlnaW49JHtvcmlnaW59YDtcbiAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3RpbmcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fd2FsbGV0ID0gd2luZG93Lm9wZW4oY29ubmVjdFVybCwgYGNlbnNvLWN1c3RvZHktJHtvcmlnaW59YCwgXCJoZWlnaHQ9OTAwLHdpZHRoPTgwMCxtZW51YmFyPW5vLHN0YXR1cz1ubyx0b29sYmFyPW5vXCIpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl93YWxsZXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIGNvbm5lY3QgdG8gd2FsbGV0XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fdGltZXJzLnB1c2god2luZG93LnNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fd2FsbGV0LmNsb3NlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFuVXAoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fd2FsbGV0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3dhbGxldC5wb3N0TWVzc2FnZSh7IHR5cGU6ICdoZWFydGJlYXQnIH0sIHRoaXMudXJsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCAxMDApKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGltZXIgPSB3aW5kb3cuc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0xvZ2dlZEluICYmIHRoaXMuX3B1YmxpY0tleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGVhclRpbWVyKHRpbWVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUodGhpcy5fcHVibGljS2V5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghdGhpcy5pc0xvZ2dlZEluICYmICF0aGlzLl9jb25uZWN0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFyVGltZXIodGltZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIlVuYWJsZSB0byBjb25uZWN0IHRvIENlbnNvXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIDEwMCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGltZXJzLnB1c2godGltZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBzaWduVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgICAgICAgdGhpcy52ZXJpZnlDYW5TaWduUmVxdWVzdHMoW3RyYW5zYWN0aW9uXSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zaWduT25lVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgc2lnbkFsbFRyYW5zYWN0aW9ucyh0cmFuc2FjdGlvbnMpIHtcbiAgICAgICAgdGhpcy52ZXJpZnlDYW5TaWduUmVxdWVzdHModHJhbnNhY3Rpb25zKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNpZ25NdWx0aXBsZVRyYW5zYWN0aW9ucyh0cmFuc2FjdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgc2VuZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLCBjb25uZWN0aW9uLCBvcHRpb25zKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB3YWxsZXQgPSB0aGlzLl93YWxsZXQ7XG4gICAgICAgICAgICBpZiAoIXdhbGxldClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb3QgQ29ubmVjdGVkXCIpO1xuICAgICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb25JZGVudGlmaWVyID0gdXVpZHY0KCk7XG4gICAgICAgICAgICB0aGlzLl9wZW5kaW5nVHJhbnNhY3Rpb25zW3RyYW5zYWN0aW9uSWRlbnRpZmllcl0gPSBudWxsO1xuICAgICAgICAgICAgY29uc3Qgc2lnbmVycyA9IG9wdGlvbnMgPyBvcHRpb25zLnNpZ25lcnMgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoc2lnbmVycyAmJiBzaWduZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNpZ25PbmVUcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgdHJhbnNhY3Rpb25JZGVudGlmaWVyKS50aGVuKHdhbGxldFRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdUcmFuc2FjdGlvbnNbdHJhbnNhY3Rpb25JZGVudGlmaWVyXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAoc2lnbmVycyA9PT0gbnVsbCB8fCBzaWduZXJzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzaWduZXJzLmxlbmd0aCkgJiYgd2FsbGV0VHJhbnNhY3Rpb24ucGFydGlhbFNpZ24oLi4uc2lnbmVycyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB3YWxsZXQucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic2VuZEZpbmFsVHJhbnNhY3Rpb25cIiwgc2VuZEZpbmFsVHJhbnNhY3Rpb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25JZGVudGlmaWVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWduYXR1cmVQdWJrZXlQYWlyczogd2FsbGV0VHJhbnNhY3Rpb24uc2lnbmF0dXJlcy5maWx0ZXIoc3AgPT4gc3Auc2lnbmF0dXJlICE9IG51bGwpLm1hcChzcCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdwdWJrZXknOiBzcC5wdWJsaWNLZXkudG9CYXNlNTgoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnc2lnbmF0dXJlJzogc3Auc2lnbmF0dXJlLnRvU3RyaW5nKCdiYXNlNjQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCB0aGlzLnVybCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0aW1lciA9IHdpbmRvdy5zZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGVuZGluZ1RyYW5zYWN0aW9uID0gdGhpcy5fcGVuZGluZ1RyYW5zYWN0aW9uc1t0cmFuc2FjdGlvbklkZW50aWZpZXJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBlbmRpbmdUcmFuc2FjdGlvbkVycm9yID0gdGhpcy5fcGVuZGluZ1RyYW5zYWN0aW9uRXJyb3JzW3RyYW5zYWN0aW9uSWRlbnRpZmllcl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBlbmRpbmdUcmFuc2FjdGlvbiAhPSBudWxsIHx8IHBlbmRpbmdUcmFuc2FjdGlvbkVycm9yICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGVhclRpbWVyKHRpbWVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVuZGluZ1RyYW5zYWN0aW9uICYmIHJlc29sdmUocGVuZGluZ1RyYW5zYWN0aW9uLnNpZ25hdHVyZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlbmRpbmdUcmFuc2FjdGlvbkVycm9yICYmIHJlamVjdChwZW5kaW5nVHJhbnNhY3Rpb25FcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgMTAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3RpbWVycy5wdXNoKHRpbWVyKTtcbiAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5zdHJ1Y3Rpb25zID0gdGhpcy5pbnN0cnVjdGlvbnNUb1NlcmlhbGl6YWJsZUluc3RydWN0aW9ucyh0cmFuc2FjdGlvbi5pbnN0cnVjdGlvbnMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHdhbGxldC5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInNlbmRUcmFuc2FjdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VuZFRyYW5zYWN0aW9uOiB7IGluc3RydWN0aW9ucywgdHJhbnNhY3Rpb25JZGVudGlmaWVyIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpcy51cmwpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0aW1lciA9IHdpbmRvdy5zZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwZW5kaW5nVHJhbnNhY3Rpb24gPSB0aGlzLl9wZW5kaW5nVHJhbnNhY3Rpb25zW3RyYW5zYWN0aW9uSWRlbnRpZmllcl07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwZW5kaW5nVHJhbnNhY3Rpb25FcnJvciA9IHRoaXMuX3BlbmRpbmdUcmFuc2FjdGlvbkVycm9yc1t0cmFuc2FjdGlvbklkZW50aWZpZXJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBlbmRpbmdUcmFuc2FjdGlvbiAhPSBudWxsIHx8IHBlbmRpbmdUcmFuc2FjdGlvbkVycm9yICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFyVGltZXIodGltZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlbmRpbmdUcmFuc2FjdGlvbiAmJiByZXNvbHZlKHBlbmRpbmdUcmFuc2FjdGlvbi5zaWduYXR1cmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlbmRpbmdUcmFuc2FjdGlvbkVycm9yICYmIHJlamVjdChwZW5kaW5nVHJhbnNhY3Rpb25FcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIDEwMCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RpbWVycy5wdXNoKHRpbWVyKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIGJ1aWxkVHJhbnNhY3Rpb24ocGVuZGluZ1RyYW5zYWN0aW9uKSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gTWVzc2FnZS5mcm9tKEJ1ZmZlci5mcm9tKFVpbnQ4QXJyYXkuZnJvbSh3aW5kb3cuYXRvYihwZW5kaW5nVHJhbnNhY3Rpb24ubWVzc2FnZSksIGMgPT4gYy5jaGFyQ29kZUF0KDApKSkpO1xuICAgICAgICByZXR1cm4gVHJhbnNhY3Rpb24ucG9wdWxhdGUobWVzc2FnZSwgQXJyYXkuZnJvbSh7IGxlbmd0aDogbWVzc2FnZS5oZWFkZXIubnVtUmVxdWlyZWRTaWduYXR1cmVzIH0sIChfdiwgaSkgPT4ge1xuICAgICAgICAgICAgbGV0IHNpZ1B1YmtleVBhaXIgPSBwZW5kaW5nVHJhbnNhY3Rpb24uc2lnbmF0dXJlcy5maW5kKHMgPT4gcy5wdWJrZXkgPT0gbWVzc2FnZS5hY2NvdW50S2V5c1tpXS50b0Jhc2U1OCgpKTtcbiAgICAgICAgICAgIHJldHVybiBiczU4LmVuY29kZShzaWdQdWJrZXlQYWlyXG4gICAgICAgICAgICAgICAgPyBCdWZmZXIuZnJvbShVaW50OEFycmF5LmZyb20od2luZG93LmF0b2Ioc2lnUHVia2V5UGFpci5zaWduYXR1cmUpLCBjID0+IGMuY2hhckNvZGVBdCgwKSkpXG4gICAgICAgICAgICAgICAgOiBERUZBVUxUX1NJR05BVFVSRV9CVUZGRVIpO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIHZlcmlmeUNhblNpZ25SZXF1ZXN0cyh0cmFuc2FjdGlvbnMpIHtcbiAgICAgICAgdHJhbnNhY3Rpb25zLmZvckVhY2godHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICAgICAgaWYgKHRyYW5zYWN0aW9uLnNpZ25hdHVyZXMuc29tZShzID0+IHMuc2lnbmF0dXJlICE9IG51bGwpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Vuc28gZG9lcyBub3Qgc3VwcG9ydCB0aGlzIHNpZ25pbmcgbW9kZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNpZ25PbmVUcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgdHJhbnNhY3Rpb25JZGVudGlmaWVyID0gdXVpZHY0KCkpIHtcbiAgICAgICAgY29uc3Qgd2FsbGV0ID0gdGhpcy5fd2FsbGV0O1xuICAgICAgICBpZiAoIXdhbGxldClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBDb25uZWN0ZWRcIik7XG4gICAgICAgIGNvbnN0IGluc3RydWN0aW9ucyA9IHRoaXMuaW5zdHJ1Y3Rpb25zVG9TZXJpYWxpemFibGVJbnN0cnVjdGlvbnModHJhbnNhY3Rpb24uaW5zdHJ1Y3Rpb25zKTtcbiAgICAgICAgdGhpcy5fcGVuZGluZ1RyYW5zYWN0aW9uc1t0cmFuc2FjdGlvbklkZW50aWZpZXJdID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHdhbGxldC5wb3N0TWVzc2FnZSh7IHR5cGU6IFwic2lnblRyYW5zYWN0aW9uXCIsIHNpZ25UcmFuc2FjdGlvbjogeyBpbnN0cnVjdGlvbnMsIHRyYW5zYWN0aW9uSWRlbnRpZmllciB9IH0sIHRoaXMudXJsKTtcbiAgICAgICAgICAgIGNvbnN0IHRpbWVyID0gd2luZG93LnNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwZW5kaW5nVHJhbnNhY3Rpb24gPSB0aGlzLl9wZW5kaW5nVHJhbnNhY3Rpb25zW3RyYW5zYWN0aW9uSWRlbnRpZmllcl07XG4gICAgICAgICAgICAgICAgY29uc3QgcGVuZGluZ1RyYW5zYWN0aW9uRXJyb3IgPSB0aGlzLl9wZW5kaW5nVHJhbnNhY3Rpb25FcnJvcnNbdHJhbnNhY3Rpb25JZGVudGlmaWVyXTtcbiAgICAgICAgICAgICAgICBpZiAocGVuZGluZ1RyYW5zYWN0aW9uICE9IG51bGwgfHwgcGVuZGluZ1RyYW5zYWN0aW9uRXJyb3IgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFyVGltZXIodGltZXIpO1xuICAgICAgICAgICAgICAgICAgICBwZW5kaW5nVHJhbnNhY3Rpb24gJiYgcmVzb2x2ZSh0aGlzLmJ1aWxkVHJhbnNhY3Rpb24ocGVuZGluZ1RyYW5zYWN0aW9uKSk7XG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmdUcmFuc2FjdGlvbkVycm9yICYmIHJlamVjdChwZW5kaW5nVHJhbnNhY3Rpb25FcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgMTAwKTtcbiAgICAgICAgICAgIHRoaXMuX3RpbWVycy5wdXNoKHRpbWVyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNpZ25NdWx0aXBsZVRyYW5zYWN0aW9ucyh0cmFuc2FjdGlvbnMpIHtcbiAgICAgICAgY29uc3Qgd2FsbGV0ID0gdGhpcy5fd2FsbGV0O1xuICAgICAgICBpZiAoIXdhbGxldClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBDb25uZWN0ZWRcIik7XG4gICAgICAgIGNvbnN0IHNlcmlhbGl6ZWRUcmFuc2FjdGlvbnMgPSB0cmFuc2FjdGlvbnMubWFwKCh0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGluc3RydWN0aW9uczogdGhpcy5pbnN0cnVjdGlvbnNUb1NlcmlhbGl6YWJsZUluc3RydWN0aW9ucyh0Lmluc3RydWN0aW9ucyksXG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25JZGVudGlmaWVyOiB1dWlkdjQoKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uSWRlbnRpZmllcnMgPSBzZXJpYWxpemVkVHJhbnNhY3Rpb25zLm1hcCgodCkgPT4gdC50cmFuc2FjdGlvbklkZW50aWZpZXIpO1xuICAgICAgICB0cmFuc2FjdGlvbklkZW50aWZpZXJzLmZvckVhY2goKHRyYW5zYWN0aW9uSWRlbnRpZmllcikgPT4gdGhpcy5fcGVuZGluZ1RyYW5zYWN0aW9uc1t0cmFuc2FjdGlvbklkZW50aWZpZXJdID0gbnVsbCk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB3YWxsZXQucG9zdE1lc3NhZ2UoeyB0eXBlOiBcInNpZ25BbGxUcmFuc2FjdGlvbnNcIiwgc2lnbkFsbFRyYW5zYWN0aW9uczogeyB0cmFuc2FjdGlvbnM6IHNlcmlhbGl6ZWRUcmFuc2FjdGlvbnMgfSB9LCB0aGlzLnVybCk7XG4gICAgICAgICAgICBjb25zdCB0aW1lciA9IHdpbmRvdy5zZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGVuZGluZ1RyYW5zYWN0aW9ucyA9IHRyYW5zYWN0aW9uSWRlbnRpZmllcnMubWFwKCh0eElkKSA9PiB0aGlzLl9wZW5kaW5nVHJhbnNhY3Rpb25zW3R4SWRdKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwZW5kaW5nVHJhbnNhY3Rpb25FcnJvcnMgPSB0cmFuc2FjdGlvbklkZW50aWZpZXJzLm1hcCgodHhJZCkgPT4gdGhpcy5fcGVuZGluZ1RyYW5zYWN0aW9uRXJyb3JzW3R4SWRdKTtcbiAgICAgICAgICAgICAgICBpZiAocGVuZGluZ1RyYW5zYWN0aW9ucy5ldmVyeSgodCkgPT4gdCAhPSBudWxsKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFyVGltZXIodGltZXIpO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHBlbmRpbmdUcmFuc2FjdGlvbnMubWFwKChwdCkgPT4gdGhpcy5idWlsZFRyYW5zYWN0aW9uKHB0KSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwZW5kaW5nVHJhbnNhY3Rpb25FcnJvcnMuc29tZSgoZSkgPT4gZSAhPSBudWxsKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFyVGltZXIodGltZXIpO1xuICAgICAgICAgICAgICAgICAgICByZWplY3QocGVuZGluZ1RyYW5zYWN0aW9uRXJyb3JzLmZpbmQoKGUpID0+IGUgIT0gbnVsbCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIDEwMCk7XG4gICAgICAgICAgICB0aGlzLl90aW1lcnMucHVzaCh0aW1lcik7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNlbnNvY3VzdG9keS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@censo-custody/solana-wallet-adapter/lib/esm/censocustody.js\n"));

/***/ }),

/***/ "./node_modules/@censo-custody/solana-wallet-adapter/lib/esm/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@censo-custody/solana-wallet-adapter/lib/esm/index.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _censocustody_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./censocustody.js */ \"./node_modules/@censo-custody/solana-wallet-adapter/lib/esm/censocustody.js\");\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in _censocustody_js__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = function(key) { return _censocustody_js__WEBPACK_IMPORTED_MODULE_0__[key]; }.bind(0, __WEBPACK_IMPORT_KEY__)\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGNlbnNvLWN1c3RvZHkvc29sYW5hLXdhbGxldC1hZGFwdGVyL2xpYi9lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBa0M7QUFDbEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BjZW5zby1jdXN0b2R5L3NvbGFuYS13YWxsZXQtYWRhcHRlci9saWIvZXNtL2luZGV4LmpzPzEyZjciXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSAnLi9jZW5zb2N1c3RvZHkuanMnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@censo-custody/solana-wallet-adapter/lib/esm/index.js\n"));

/***/ })

}]);